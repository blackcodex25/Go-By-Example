package main

import (
	f "fmt"
)

/* การใช้งานฟังก์ชันนิรนาม (Anonymous Functions) และ closure
ภาษา Go รองรับการใช้งานฟังก์ชันนิรนาม (anonymous
functions) ซึ่งสามารถสร้าง closure ได้ ฟังก์ชันนิรนามมี
ประโยชน์เมื่อเราต้องการนิยามฟังก์ชันแบบอินไลน์ (inline)
โดยไม่จำเป็นต้องตั้งชื่อฟังก์ชัน ฟังก์ชันเหล่านี้สามารถเก็บค่า
บางอย่างในสโคปของมันเพื่อสร้าง closure ที่ทำให้ค่าหรือ
สถานะภายในฟังก์ชันนั้นๆ ยังคงอยู่ระหว่างการเรียกใช้แต่ละครั้ง

คุณสมบัติและการใช้งานฟังก์ชันนิรนามและ Closure
1.ฟังก์ชันนิรนาม (Anonymous Functions)
ฟังก์ชันนิรนามคือฟังก์ชันที่ถูกนิยามโดยไม่มีชื่อ และ
สามารถถูกใช้งานได้ในบริบทที่ต้องการสร้างฟังก์ชัน
แบบอินไลน์

2.การสร้าง Closure
ฟังก์ชัน intSeq คืนค่าอีกฟังก์ชันหนึ่ง ซึ่งถูกนิยามแบบนิรนาม (anonymous function)
ภายในบอดี้ของ intSeq
ฟังก์ชันที่ถูกคืนค่าจะทำหน้าที่เป็น closure โดนเก็บค่าของตัวแปร i จากสโคปที่มันถูก
สร้างขึ้น

3.การใช้งาน Closure
เมื่อเรียกใช้ intSeq ฟังก์ชันจะคืนค่าฟังก์ชันนิรนามที่สามารถใช้งานเป็น closure ได้
ตัวแปร nextInt จะเก็บฟังก์ชันที่คืนค่าจาก
intSeq และเมื่อเรียกใช้ nextInt() ค่าของ i ที่ถูกปิดคลุม (closed over)
จะถูกอัปเดตและส่งกลับ

4.การตรวจสอบสถานะที่เป็นเอกลักษณ์
การสร้างฟังก์ชัน intSeq ใหม่จะสร้าง closure
ใหม่ที่มีสถานะ (state) เป็นของตัวเอง ดังนั้นการ
เรียกใช้ newInts จะเริ่มต้นค่าของ i ใหม่
*/
// ฟังก์ชัน intSeq ถูกนิยามให้คืนค่าเป็นฟังก์ชันที่รับ () int
// ภายใน intSeq มีการประกาศตัวแปร i ที่มีค่าเริ่มต้นเป็น 0
// ฟังก์ชันนิรนามภายใน intSeq จะเพิ่มค่าของ i ขึ้นทีละ 1 (i++)
// และส่งค่าของ i กลับ (return)
// ฟังก์ชันที่ถูกนิยามนี้จะถูกคืนค่าออกจาก intSeq และ
// สามารถนำไปใช้งานต่อในภายหลังได้
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}
func main() {
	// การใช้งานฟังก์ชันที่ถูกคืนค่าไว้ในตัวแปร nextInt
	// เรียกใช้ intSeq และเก็บฟังก์ชันที่ถูกคืนค่าไว้ในตัวแปร nextInt
	nextInt := intSeq()

	// การเรียกใช้ nextInt() แต่ละครั้งจะเพิ่มค่าของ i
	// ทีละ 1 และส่งค่าปัจจุบันของ i กลับมา
	// พิมพ์ค่า 1, 2 และ 3 ตามลำดับเมื่อเรียกใช้ nextInt() สามครั้ง
	f.Println(nextInt())
	f.Println(nextInt())
	f.Println(nextInt())

	// การสร้าง closure ใหม่และการตรวจสอบสถานะ
	// สร้าง closure ใหม่โดยเรียกใช้ intSeq อีกครั้ง ซึ่งจะเริ่มต้นค่า i เป็น 0 ใหม่
	newInts := intSeq()
	// การเรียกใช้ newInts() จะเพิ่มค่า i ขึ้นเป็น 1 และพิมพ์ค่า 1 ออกจอ
	f.Println(newInts())
	// สิ่งนี้แสดงให้เห็นว่า closure แต่ละตัวจะมีสถานะ (state) ของตัวเอง
	// ซึ่งไม่ขึ้นกับ closure อื่น
}

/* สรุป
โค้ดนี้แสดงให้เห็นถึงการใช้งานฟังก์ชันนิรนาม (Anonymous Functions) และการสร้าง
closure ในภาษา Go ฟังก์ชันนิรนามสามารถเก็บค่าบางอย่างในสโคปของมันเพื่อสร้าง
closure ที่มีสถานะเฉพาะตัว การเรีกยใช้ closure นั้นซ้ำๆ
จะทำให้เห็นผลกระทบของสถานะที่ถูกเก็บอยู่ภายใน closure
ซึ่งสามารถนำไปใช้ในการจัดการสถานะในโปรแกรมได้อย่างมีประสิทธิภาพ
*/
