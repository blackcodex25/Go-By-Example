package main

import (
	f "fmt"
)

/* การใช้งาน Recursive Functions และ Recursive Closures ในภาษา Go
บทความนี้กล่าวถึงการใช้งานฟังก์ชันที่เรียกตัวเองซ้ำๆ (recursive functions) และ
การทำให้ closures สามารถทำงานแบบ recursive ได้ในภาษา Go ซึ่งเป็นเทคนิคที่
สำคัญในการเขียนโปรแกรม

คุณสมบัติและการใช้งาน Recursive Functions และ Recursive Closures
1.ฟังก์ชันแบบ Recursive
ฟังก์ชัน fact เป็นตััวอย่างของฟังก์ชันที่เรียกตัวเองซ้ำๆ (recursive function)
ฟังก์ชันนี้จะทำงานซ้ำๆ จนกว่าจะถึง base case ซึ่ง
ในกรณีนี้คือเมื่อ n == 0 ฟังก์ชันจะหยุดการเรียกซ้ำและคืนค่า 1
การคำนวณค่า Factorial เช่น fact(7) จะใช้ฟังก์ชันนี้ในการคำนวณผลลัพธ์

2.Closures แบบ Recursive
ใน Go, closures สามารถทำงานแบบ recursive
ได้ แต่จำเป็นต้องประกาศตัวแปรที่เก็บฟังก์ชันนั้นก่อน
ที่จะนิยาม (define) ฟังก์ชัน
ในตัวอย่างนี้ fib ถูกประกาศเป็น var ก่อนที่จะนิยามฟังก์ชันที่ใช้ fib เองในการทำงาน
แบบ recursive
การประกาศ fib ล่วงหน้านี้ช่วยให้ Go รู้ว่าจะต้อง
เรียกใช้ฟังก์ชันใดเมื่อ fib ถูกอ้างอิงภายในฟังก์ชัน
*/
// ฟังก์ชัน fact คำนวณค่า factorial ของ n โดยใช้ การเรียกตัวเองซ้ำ (recursion)
func fact(n int) int {
	// เมื่อ n == 0 ฟังก์ชันจะคืนค่า 1 ซึ่งเป็น base
	// case ของการคำนวณ factorial
	/* ในกรณีที่ n > 0 ฟังก์ชันจะเรียกตัวเองซ้ำโดยใช้ n - 1
	และนำผลลัพธ์มาคูณกับ n */
	if n == 0 {
		return 1
	}
	return n * fact(n-1)
}
func main() {
	// เรียกใช้ฟังก์ชัน fact(7) ซึ่งจะคำนวณค่า 7 (factorial ของ 7)
	f.Println(fact(7)) // ผลลัพธ์ที่ได้คือ 5040 พิมพ์ออกจอภาพ

	// การประกาศฟังก์ชันและนิยามฟังก์ชัน fib
	// ก่อนที่จะนิยามฟังก์ชัน fib เราจำเป็นต้องประกาศ
	// ตัวแปร fib ก่อน เพื่อให้สามารถทำงานแบบ recursive ได้
	var fib func(n int) int

	// fib ถูกนิยามเป็นฟังก์ชันที่คำนวณค่า Finonacci
	// ของ n โดยใช้สูตร fib(n-1) + fib(n-2)
	// ฟังก์ชันจะคืนค่า n เมื่อ n < 2 (กรณี base case คือ 0 และ 1)
	fib = func(n int) int {
		if n < 2 {
			return n
		}
		return fib(n-1) + fib(n-2)
	}
	// การเรียกใช้ fib(7) จะคำนวณค่า Fibonacci ของ 7 ซึ่งผลลัพธ์คือ 13
	f.Println(fib(7))
}

/* สรุป
โค้ดนี้แสดงให้เห็นถึงการใช้งานฟังก์ชันแบบ recursive และ recursive closures
ในภาษา Go ฟังก์ชัน fact แสดงการคำนวณค่า factorial โดยการเรียกตัวเองซ้ำ
ขณะที่ฟังก์ชัน fib แสดงการใช้งาน closure ที่สามารถทำงานแบบ recursive
ได้โดยการประกาศตัวแปรฟังก์ชันก่อนนิยาม การใช้งานแบบนี้ ช่วยให้สามารถเขียนฟังก์ชัน
ที่ซับซ้อนได้อย่างมีประสิทธิภาพในภาษา Go
*/
