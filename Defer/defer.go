package main

import (
	"fmt"
	"os"
)

/*
Defer (เลื่อนการทำงาน) Defer ใช้เพื่อรับประกันว่าการเรียกฟังก์ชัน
จะถูกดำเนินการในภายหลังในช่วงการทำงานของโปรแกรม
มักใช้เพื่อวัตถุประสงค์ในการทำ (cleanup) defer
มักถูกใช้ในสถานการณ์ที่ภาษาอื่นๆ อาจใช้ e.g. ensure และ finally

สมมติว่าเราต้องการสร้างไฟล์ เขียนข้อมูลลงในไฟล์และปิดไฟล์
เมื่อทำงานเสร็จ นี่คือตัวอย่างวิธีการทำสิ่งนี้ด้วย defer

ทันทีหลังจากที่เราได้รับออบเจ็กต์ไฟล์จากฟังก์ชัน createFile
เราใช้ defer เพื่อเลื่อนการปิดไฟล์ด้วยฟังก์ชัน closeFile ซึ่งจะ
ถูกดำเนินการเมื่อสิ้นสุดฟังก์ชันที่ล้อมรอบอยู่ (ในที่นี้คือ main)
หลังจากที่ writeFile ทำงานเสร็จแล้ว

สิ่งสำคัญคือต้องตรวจสอบข้อผิดพลาดเมื่อปิดไฟล์
แม้แต่ในฟังก์ชันที่ถูกเลื่อนการทำงานด้วย defer
เมื่อรันโปรแกรม จะยืนยันได้ว่าไฟล์ถูกปิดหลังจากเขียนข้อมูลเสร็จแล้ว
*/
// ฟังก์ชัน createFile ทำหน้าที่ในการสร้างไฟล์ที่ตำแหน่งที่กำหนด
// ผ่านพารามิเตอร์ p ซึ่งเป็นสตริงที่ระบุเส้นทางของไฟล์
func createFile(p string) *os.File {
	// ใช้เพื่อแสดงข้อความ "creating" ในคอนโซลเมื่อฟังก์ชันถูกเรียกใช้งาน
	fmt.Println("creating")
	// ฟังก์ชัน os.Create(p) จะถูกเรียกเพื่อลองสร้างไฟล์ที่
	// ตำแหน่งที่ระบุใน p
	// ถ้าไฟล์มีอยู่แล้ว จะถูกเปิดขึ้นใหม่และข้อมูลเดิมจะถูกเขียนทับ
	// ถ้าไฟล์ยังไม่มีอยู่ จะถูกสร้างขึ้นใหม่ที่ตำแหน่งที่ระบุ
	f, err := os.Create(p)
	// ฟังก์ชัน os.Create จะคืนค่า 2 ค่า คือ ไฟล์ที่ถูกสร้าง
	// (*os.File) และข้อผิดพลาด (err) ถ้าการสร้างไฟล์ล้มเหลว
	// ใช้การตรวจสอบเงื่อนไขเพื่อตรวจว่ามีข้อผิดพลาดหรือไม่
	if err != nil {
		// ถ้ามีข้อผิดพลาดจะใช้ panic(err)
		// ซึ่งจะหยุดการทำงานของโปรแกรมทันทีและแสดงข้อผิดพลาดออกมา
		panic(err)
	}
	/* ถ้าการสร้างไฟล์สำเร็จ ฟังก์ชันจะคืนค่าตัวแปร f
	ซึ่งเป็นพอยน์เตอร์ไปยังไฟล์ (*os.File)
	เพื่อให้ฟังก์ชันอื่นสามารถใช้งานไฟล์นี้ต่อได้
	*/
	return f
}

// สร้างฟังก์ชัน writeFile เขียนข้อความ "data" ลงในไฟล์ที่กำหนด
// โดยผ่านพารามิเตอร์ f *os.File
func writeFile(f *os.File) {
	// พิมพ์ "writing" ลงในคอนโซล
	fmt.Println("writing")
	fmt.Fprintln(f, "data")
}

// สร้างฟังก์ชัน CloseFile มีพารามิเตอร์ f
// รับเป็นพอยน์เตอร์ไปยังไฟล์ (*os.File)
// ซึ่งไฟล์นี้อาจถูกสร้างหรือเปิดมาก่อนหน้านี้โดยฟังก์ชันอื่น
// เช่น createFile
func closeFile(f *os.File) {
	// แสดงข้อความในคอนโซลว่าโปรแกรมกำลังปิดไฟล์ f
	// เพื่อให้ผู้ใช้ทราบว่ากำลังดำเนินการปิดไฟล์
	fmt.Println("closing")
	// ฟังก์ชัน f.Close() คืนค่าข้อผิดพลาด (error)
	// ถ้ามีปัญหาในการปิดไฟล์
	err := f.Close()
	// ตรวจสอบว่าการปิดไฟล์มีข้อผิดพลาดหรือไม่
	if err != nil {
		// ถ้ามีข้อผิดพลาด โปรแกรมจะแสดงข้อความข้อผิดพลาด
		// ไปยัง standard error (os.Stderr)
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		// จากนั้นจะใช้ os.Exit(1) เพื่อบังคับให้โปรแกรม
		// หยุดทำงานด้วย exit status 1 ซึ่งแสดงว่ามีความ
		// ล้มเหลวเกิดขึ้น
		os.Exit(1)
	}
}

// สร้างไฟล์ (createFile) และปิดไฟล์ (closeFile)
// แล้วเรียกฟังก์ชัน writeFile และ closeFile
func main() {
	// เรียกใช้ฟังก์ชัน createFile เพื่อสร้างไฟล์
	f := createFile("./defer.txt")
	// ใช้คำสั่ง defer  เพื่อบอกให้ฟังก์ชัน closeFile
	// ทำงานหลังจากฟังก์ชัน main ทำงานเสร็จ
	// ซึ่งเป็นการแน่ใจว่าไฟล์จะถูกปิดเมื่อทำงานเสร็จ
	defer closeFile(f)
	// เรียกฟังก์ชัน writeFile เพื่อเขียนข้อมูลลงในไฟล์
	writeFile(f)
}

/* สร้างไฟล์ (createFile):
1.ฟังก์ชัน createFile:
สร้างไฟล์ใหม่ที่ตำแหน่งที่กำหนด (ในกรณีนี้คือ "./defer.txt")
ด้วยฟังก์ชัน os.Create()
ถ้าการสร้างไฟล์เกิดข้อผิดพลาด (ค่า err ไม่เป็น nil)
จะใช้ panic(err) เพื่อหยุดโปรแกรมและแสดงข้อผิดพลาด
ถ้าสร้างไฟล์สำเร็จ ฟังก์ชันจะคืนค่าไฟล์ (*os.File)
กลับมาให้ใช้งานในฟังก์ชันอื่น

2.ฟังก์ชัน writeFile:
เขียนข้อมูลลงในไฟล์ที่รับเข้ามาในรูปแบบ *os.File
โดยใช้ fmt.Fprintln(f, "data") เพื่อเขียนคำว่า
"data" ลงในไฟล์

3.ฟังก์ชัน closeFile:
ปิดไฟล์โดยใช้ฟังก์ชัน f.Close()
ถ้าการปิดไฟล์เกิดข้อผิดพลาด จะใช้
fmt.Fprintf(os.Stderr, "error: %v\n", err) เพื่อ
แสดงข้อความข้อผิดพลาดทาง stderr และใช้ os.Exit(1)
เพื่อออกจากโปรแกรมพร้อมกับสถานะที่แสดงว่ามีข้อผิดพลาด

4.ฟังก์ชัน main:
เรียก createFile เพื่อสร้างไฟล์
ใช้คำสั่ง defer closeFile(f) เพื่อบอกให้ฟังก์ชัน
closeFile ทำงานหลังจากฟังก์ชัน main ทำงานเสร็จ
ซึ่งเป็นการแน่ใจว่าไฟล์จะถูกปิดเมื่อทำงานเสร็จ
เรียกฟังก์ชัน writeFile เพื่อเขียนข้อมูลลงในไฟล์
*/
/* ลำดับการทำงาน:
สร้างไฟล์ที่ตำแหน่ง ./defer.txt
ใช้ defer เพื่อเลื่อนการปิดไฟล์ออกไปจนกว่าโปรแกรมจะทำงานเสร็จ
เขียนข้อมูล "data" ลงในไฟล์
ปิดไฟล์เมื่อโปรแกรมทำงานเสร็จสิ้น

โปรแกรมจะสร้างไฟล์ defer.txt ขึ้นในตำแหน่งปัจจุบัน (current directory)
เขียนคำว่า "data" ลงไป และปิดไฟล์ในตอนสุดท้าย
*/
