การเขียนและจัดการข้อผิดพลาด (Error Handling) 
ในโปรแกรม Go เป็นสิ่งสำคัญในการ
ทำให้โปรแกรมทำงานได้อย่างมีประสิทธิภาพและเชื่อถือได้
แนวทางปฏิบัติที่ดีที่สุดในการ จัดการข้อผิดพลาดใน Go มีดังนี้:

1.ใช้ค่าผลลัพธ์แบบ error อย่างสม่ำเสมอ
Go ใช้การคืนค่าประเภท error เป็นค่าผลลัพธ์แบบหนึ่งจากฟังก์ชันแทนการใช้
exception เหมือนภาษาบางภาษา นี่เป็นแนวทางปฏิบัติที่ถือว่าเป็นมาตรฐานใน Go
ตรวจสอบและจัดการข้อผิดพลาดในทันทีหลังจากเรียกใช้ฟังก์ชันที่อาจคืนค่า error
เพื่อหลีกเลี่ยงการปล่อยให้ข้อผิดพลาดส่งผลกระทบต่อการทำงานของโปรแกรม
f, err := os.Open("file.txt")
if err != nil {
    return err // ส่งต่อข้อผิดพลาดขึ้นไป หรือ handle ข้อผิดพลาดที่นี่
}
defer f.Close()

2.จัดการข้อผิดพลาดอย่างเฉพาะเจาะจง
หากเป็นไปได้ ให้ตรวจสอบประเภทของข้อผิดพลาดเพื่อจัดการเฉพาะเจาะจงสำหรับข้อ
ผิดพลาดแต่ละประเภท การทำเช่นนี้จะทำให้สามารถจัดการกับสถานการณ์ได้ดียิ่งขึ้น
if err != nil {
    if os.IsNotExist(err) {
        fmt.Println("File does not exist")
    } else {
        return err
    }
}
ใช้ errors.Is และ errors.As สำหรับข้อผิดพลาดแบบซ้อน (Wrapped Errors)
ใช้ฟังก์ชัน errors.Is หรือ errors.As ในกรณีที่มีการ "wrap" ข้อผิดพลาด 
เพื่อให้สามารถตรวจสอบข้อผิดพลาดภายในได้
errors.Is ใช้สำหรับตรวจสอบว่า error มีค่าเท่ากับ error ที่ระบุหรือไม่
errors.As ใช้สำหรับแปลง (cast) error เป็นชนิดที่ระบุ
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("File not found")
}

4.ใช้ fmt.Errorf สำหรับการเพิ่ม context ในข้อความข้อผิดพลาด
หากต้องการเพิ่มข้อมูลเพิ่มเติมในข้อผิดพลาดเพื่อให้เข้าใจได้ง่ายขึ้น ให้ใช้
fmt.Errorf และ %w เพื่อ wrap ข้อผิดพลาดเดิมไว้
if err != nil {
    return fmt.Errorf("failed to open file: %w", err)
}

5.ใช้ panic เฉพาะในกรณีที่ไม่สามารถกู้คืนได้
ควรใช้ panic ในกรณีที่เกิดข้อผิดพลาดร้ายแรงหรือไม่คาดคิดที่ไม่สามารถจัดการได้
เช่น การเกิด bug ภายในระบบ หรือเงื่อนไขที่ไม่ควรเกิดขึ้นในโปรแกรมปกติ
if criticalError {
    panic("Critical error encountered")
}

6.การใช้ defer สำหรับการจัดการ resource cleanup
ในกรณีที่มีการใช้ resource เช่นไฟล์หรือการเชื่อมต่อเครือข่าย ควรใช้ defer เพื่อให้
แน่ใจว่ามีการปิด resource หลังการใช้งาน แม้จะเกิดข้อผิดพลาดในระหว่างการทำงาน
f, err := os.Open("file.txt")
if err != nil {
    return err
}
defer f.Close()

7.การจัดการข้อผิดพลาดเป็นระดับ (Error Propagation)
ในหลายกรณี เมื่อเกิดข้อผิดพลาด คุณสามารถเลือกที่จะส่งข้อผิดพลาดนี้ไปยังฟังก์ชัน
ที่เรียกใช้โดยไม่จัดการข้อผิดพลาดนั้นในทันที (Error Propagation)
func readFile() error {
    f, err := os.Open("file.txt")
    if err != nil {
        return fmt.Errorf("failed to open file: %w", err)
    }
    defer f.Close()
    // ...
    return nil
}

8.การใช้ Custom Errors (ข้อผิดพลาดเฉพาะ)
ในบางครั้ง อาจต้องการสร้างข้อผิดพลาดที่มีความเฉพาะเจาะจงเพื่อให้การจัดการข้อ
ผิดพลาดเข้าใจง่ายยิ่งขึ้น คุณสามารถสร้าง custom errors โดยการใช้ errors.New
หรือ fmt.Errorf
var ErrInvalidInput = errors.New("invalid input")

func validate(input string) error {
    if input == "" {
        return ErrInvalidInput
    }
    return nil
}

สรุป:
การจัดการข้อผิดพลาดใน Go ควรทำอย่างสม่ำเสมอและมีการตรวจสอบข้อผิดพลาดอย่างชัดเจน
ควรใช้ panic ในกรณีที่เกิดข้อผิดพลาดรุนแรงที่ไม่สามารถจัดการได้ และควรใช้
การคืนค่าประเภท error เพื่อบ่งบอกถึงข้อผิดพลาดในสถานการณ์ปกติ
