โค้ดส่วนนี้เป็นการสร้าง goroutine ที่ทำงานในพื้นหลังเพื่อรอรับค่าจาก Ticker
และจัดการกับค่าที่ได้รับผ่านการใช้ select ซึ่งเป็นโครงสร้างควบคุมใน Go 
ที่ช่วยให้เราสามารถเลือกทำงานกับหลายๆ channel พร้อมกันได้

การทำงานของ go func() { ... }()
go func() {
    for {
        select {
        case <-done:
            return
        case t := <-ticker.C:
            fmt.Println("Tick at", t)
        }
    }
}()
การสร้าง Goroutine
go func() { ... }()
ส่วนนี้เป็นการสร้าง goroutine ใหม่ซึ่งเป็นการรัน
ฟังก์ชันแบบ asynchronous (ไม่ต้องรอให้การทำงานในฟังก์ชันนี้เสร็จสิ้นก่อน)
ทำให้โค้ดในฟังก์ชัน main สามารถทำงานต่อไปได้ในขณะที่ goroutine นี้ทำงาน
ในพื้นหลัง

การวนลูปด้วย for
for { ... }
ลูป for ที่ไม่มีเงื่อนไขจะทำงานอย่างไม่สิ้นสุด
(infinite loop) จนกว่าจะเจอคำสั่ง return หรือ
break ทำให้ goroutine นี้จะวนลูปเพื่อรอรับค่า tick
จาก Ticker ตลอดเวลา

การเลือกทำงานกับ select
select { ... }
คำสั่ง select ใช้สำหรับรอรับค่าจากหลายๆ
channel พร้อมกัน และเลือกทำงานกับ channel ที่
พร้อมใช้งานก่อนในแต่ละรอบของลูป

case <-done:
หากมีค่าถูกส่งเข้ามาใน channel done (ซึ่งบ่งบอกว่าให้หยุดทำงาน)
คำสั่งใน case นี้จะถูก เลือกและทำงาน โดยในกรณีนี้จะทำการ return
ออกจากฟังก์ชันเพื่อหยุดการทำงานของ goroutine นี้ทันที

case t := <-ticker.C:
หากมีค่าถูกส่งเข้ามาใน channel ticker.C (ซึ่งเป็นค่าที่ Ticker ส่งมาในแต่ละครั้ง)
คำสั่งใน case นี้จะถูกเลือกและทำงาน โดยในกรณีนี้จะทำการพิมพ์ค่าของ t 
(เวลาที่ได้รับจาก Ticker)
ออกมาในรูปแบบ Tick at [เวลา]

การหยุด Goroutine
เมื่อ channel done ถูกส่งค่า true เข้าไป
(จากโค้ดส่วน done <- true ในฟังก์ชัน main) select จะเลือก
case <-done: ทำให้ goroutine หยุดการทำงานโดยการออก
จากลูปและฟังก์ชันนี้

สรุปการทำงาน
Goroutine นี้ทำหน้าที่รับค่า tick จาก Ticker 
และพิมพ์ค่าเวลาที่ได้รับออกมาในแต่ละครั้ง
Goroutine จะทำงานวนลูปตลอดเวลาจนกว่าจะได้รับ
สัญญาณจาก channel done ให้หยุด ซึ่งจะทำให้
Goroutine นี้หยุดทำงานทันที
