package main

import (
	"fmt"
	"time"
)

/*
วิธีการสร้าง "worker pool" โดยใช้ goroutines และ channels
นี่คือตัวอย่าง worker ซึ่งเราจะเรียกใช้งานหลายอินสแตนซ์
พร้อมกัน workers เหล่านี้จะรับงานจาก Channels jobs และส่ง
ผลลัพธ์ที่ได้ไปยัง Channels results เราจะใช้การหยุดพัก 1 วินาทีต่อหนึ่งงาน
เพื่อจำลองการทำงานที่ใช้เวลานาน

ในการใช้กลุ่มของ workers เราจำเป็นต้องส่งงานให้กับพวกเขา
และเก็บรวบรวมผลลัพธ์จากพวกเขา เราจะสร้าง Channel 2 ช่องเพื่อทำสิ่งนี้
นี่คือลำดับของการเริ่มต้น workers 3 ตัว ซึ่งในขั้นแรกจะถูก
บล็อกไว้เพราะยังไม่มีงานใด ๆ ที่ถูกส่งเข้ามา

ต่อไป เราส่งงาน 5 งานเข้าไปในช่องทาง jobs และปิดช่องทาง
นั้นเพื่อบอกว่านี่คืองานทั้งหมดที่เรามี

สุดท้าย เราเก็บรวบรวมผลลัพธ์ทั้งหมดจากงานที่ทำ นี่เป็นการ
ยืนยันด้วยว่า worker goroutines ทั้งหมดได้ทำงานเสร็จสิ้นแล้ว
อีกวิธีหนึ่งในการรอให้หลาย goroutines ทำงานเสร็จคือ
การใช้ WaitGroup

โปรแกรมที่กำลังทำงานจะแสดงให้เห็นว่า 5 งานกำลังถูกดำเนิน
การโดย workers ต่าง ๆ โปรแกรมนี้ใช้เวลาเพียงประมาณ 2 วินาที
แม้ว่าจะทำ/แม้ว่าจะทำงานที่รวมกันแล้วใช้เวลาประมาณ 5 วินาที
งานที่รวมกันแล้วใช้เวลาประมาณ 5 วินาที
เนื่องจากมี workers 3 ตัวทำงานพร้อมกัน
*/
// ฟังก์ชัน worker รับพารามิเตอร์ id ชนิด int jobs ชนิด channel
// และ results ชนิด channel และส่งผลลัพธ์
func worker(id int, jobs <-chan int, results chan<- int) {
	// ภายในลูป for j := range jobs worker จะดึงงาน
	// จาก channel jobs มาประมวลผลทีละงาน
	for j := range jobs {
		// Worker จะแสดงข้อความเมื่อเริ่มและเสร็จสิ้นการประมวลผลงานแต่ละงาน
		fmt.Println("worker", id, "Started job", j)
		// หลังจากประมวลผลเสร็จ (ใช้เวลา 1 วินาทีเพื่อจำลองการประมวลผลด้วย time.Sleep)
		time.Sleep(time.Second)
		fmt.Println("worker", id, "finished job", j)
		// worker จะส่งผลลัพธ์ของงาน (j * 2) กลับไปที่ channel results
		results <- j * 2
	}
}

func main() {
	// สร้างงานจำนวน numJobs (5 งาน)
	const numJobs = 10

	// สร้าง channel jobs และ results ที่มีขนาด buffer เท่ากับจำนวนงาน
	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	// ลูป for w := 1; w <= 3; w++ สร้าง worker 3 ตัว
	// ที่ทำงานพร้อมกัน (ทำงานใน goroutine)
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	// ลูป for j := 1; j <= numJobs; j++ ส่งงาน (ตัวเลข 1 ถึง 5)
	// ไปยัง channel jobs
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	// เมื่อส่งงานทั้งหมดแล้ว close(jobs) จะปิด channel jobs
	// เพื่อบอกว่าไม่มีงานที่จะส่งอีก
	close(jobs)

	// ลูป for a := 1; a <= numJobs; a++ รอรับผลลัพธ์จาก channel results
	// โดยดึงข้อมูลจาก channel results จำนวน 5 ครั้ง
	for a := 1; a <= numJobs; a++ {
		<-results
	}
}

/* Note:
<-chan T
เป็นการประกาศ channel ที่ใช้ รับข้อมูล อย่างเดียวจาก channel นั้น
โดยไม่สามารถส่งข้อมูลเข้าไปได้ jobs <-chan int หมายความว่า jobs
เป็น channel ที่รับข้อมูลประเภท int เท่านั้น ไม่สามารถใช้ jobs <- someValue
เพื่อส่งข้อมูลเข้าไปใน channel นี้ได้

chan<- T
เป็นการประกาศ channel ที่ใช้ ส่งข้อมูล อย่างเดียว (send-only)
ไปยัง channel นั้น โดยไม่สามารถรับข้อมูลจากมันได้
ตัวอย่างเช่น results chan<- int หมายความว่า
results เป็น channel ที่ส่งข้อมูลประเภท int เท่านั้น
ไม่สามารถใช้ <-results เพื่อดึงข้อมูลจาก channel นี้ได้
*/

/* สรุปการทำงาน
โค้ดนี้สร้าง worker 3 ตัว เพื่อประมวลผลงาน 5 งาน โดย
แต่ละ worker จะดึงงานจาก channel jobs มาประมวลผล
เมื่อ worker ประมวลผลงานเสร็จแล้วก็จะส่งผลลัพธ์
กลับไปยัง channel results

การปิด channel jobs หลังจากส่งงานทั้งหมดเสร็จสิ้น
เป็นการบอก worker ว่าไม่มีงานเพิ่มเติมแล้ว

ในตอนท้ายของโปรแกรมจะมีการรอรับผลลัพธ์จากทุกงาน
ก่อนที่โปรแกรมจะสิ้นสุด
*/
/* การใช้งานในบริบทของ Worker Pool
ในโค้ด Worker Pool
jobs <-chan int: หมายความว่า worker แต่ละตัวจะรับงานจาก channel jobs เท่านั้น
results chan<- int: หมายความว่า worker แต่ละตัวจะส่งผลลัพธ์ไปยัง
channel results เท่านั้น

การกำหนดทิศทางนี้ช่วยให้โค้ดปลอดภัยมากขึ้น และลดความ
เสี่ยงในการใช้งาน channel ผิดประเภทเช่น การพยายามส่งข้อมูลเข้า channel
ที่ควรจะใช้รับข้อมูลอย่างเดียว เป็นต้น
*/
