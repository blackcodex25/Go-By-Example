package main

import (
	f "fmt"
	"time"
)

/* วิธีการจัดการกับ Timeout
ในโปรแกรม Go โดยเฉพาะในกรณีที่โปรแกรมต้องเชื่อมต่อกับ
ทรัพยากรภายนอกหรือมีการทำงานที่ต้องการการจำกัดเวลาการ
ทำงาน การใช้ channels และ select ทำให้การ
จัดการกับ TimeOut ใน Go เป็นเรื่องง่าย

คำอธิบายบทความ
ความสำคัญของ Timeout:
การจัดการกับ Timeout เป็นสิ่งสำคัญสำหรับ
โปรแกรมที่เชื่อมต่อกับทรัพยากรภายนอกเช่น การ
เรียก API หรือการทำงานที่ต้องมีการจำกัดเวลาการ
ทำงาน เพื่อป้องกันการทำงานที่ไม่สิ้นสุด (infinite wait)
หรือการรอคอยที่นานเกินไป

การใช้ Channels และ Select เพื่อจัดการกับ Timeout:
บทความแสดงตัวอย่างที่มีการเรียกใช้ฟังก์ชันภายนอก
ที่ใช้เวลา 2 วินาทีในการส่งผลลัพธ์กลับมาทาง channel c1
select ถูกใช้เพื่อจัดการกับ Timeout โดยมี
สองเงื่อนไข คือ รอผลลัพธ์จาก c1 และรอ Timeout 1 วินาที
(time.After(1 * time.Second))

การเลือกเงื่อนไขใน Select:
select จะเลือกทำงานกับเงื่อนไขที่พร้อมก่อน ถ้า
การทำงานของฟังก์ชันภายนอกใช้เวลามากกว่า 1
วินาที (เช่นในกรณีนี้) โปรแกรมจะเข้าสู่กรณีของการ timeout

การยืดเวลา Timeout:
ในตัวอย่างที่สอง จะมีการยืดเวลา timeout เป็น 3
วินาที ซึ่งเพียงพอสำหรับการรับผลลัพธ์จากฟังก์ชัน
ภายนอกที่ใช้เวลา 2 วินาทีในการทำงาน

*/

func main() {
	// ส่วนที่ 1: กำหนด timeout 1 วินาที
	c1 := make(chan string, 1) // สร้าง channels ชือ c1 พร้อม buffer ขนาด 1
	go func() {
		time.Sleep(2 * time.Second) // หน่วงเวลา 2 วินาที
		c1 <- "result 1"            // ส่งข้อความ "result 1" ลงใน channels c1
	}()

	select {
	case res := <-c1: // รอรับผลลัพธ์จาก channels c1
		f.Println(res) // ถ้าได้รับผลลัพธ์ก่อน timeout พิมพ์ผลลัพธ์
	case <-time.After(1 * time.Second): // รอเวลาหมดเวลา 1 วินาที
		f.Println("timeout 1")
	}

	// ส่วนที่ 2: กำหนด timeout 3 วินาที
	c2 := make(chan string, 1) // สร้าง channel ชื่อ c2 พร้อม buffer ขนาด 1
	go func() {
		time.Sleep(2 * time.Second) // หน่วงเวลา 2 วินาที
		c2 <- "result 2"            // ส่งข้อความ "result 2" ลงใน channel c2
	}()

	select {
	case res := <-c2: // รอรับผลลัพธ์จาก channel c2
		f.Println(res) // ถ้าได้รับผลลัพธ์ก่อน timeout พิมพ์ผลลัพธ์
	case <-time.After(3 * time.Second): // รอเวลาหมดเวลา 3 วินาที
		f.Println("timeout 2") // ถ้าเวลาหมดก่อน พิมพ์ข้อความ "timeout 2"
	}
}

/*Logic ของโค้ด
สร้าง channel c1 ที่มี buffer ขนาด 1 แล้วเริ่ม
goroutine ที่หน่วงเวลา 2 วินาที ก่อนส่งข้อความ
result 1" ลงใน channel c1
ใช้ select เพื่อรอผลลัพธ์จาก channel c1 หรือ timeout 1 วินาที
เนื่องจากฟังก์ชันหน่วงเวลา 2 วินาที จึงเกิด timeout และพิมพ์ "timeout 1"

ส่วนที่สองของโค้ด:
สร้าง channel c2 ที่มี buffer ขนาด 1 แล้วเริ่ม
goroutine ที่หน่วงเวลา 2 วินาที ก่อนส่งข้อความ
result 2 ลงใน channel c2
ใช้ select เพื่อรอผลลัพธ์จาก channel c2
หรือ timeout 3 วินาที
ในกรณีนี้ผลลัพธ์จะถูกส่งกลับภายใน 2 วินาที ซึ่งอยู่
ภายใน timeout 3 วินาที จึงพิมพ์ "result 2"
*/
/* การทำงานของโค้ด
ในส่วนแรกของโค้ด เนื่องจาก timeout (1 วินาที) น้อย
กว่าการทำงานของ goroutine (2 วินาที)
โปรแกรมจะเข้าสู่กรณี timeout และพิมพ์ "timeout 1"

ในส่วนที่สองของโค้ด timeout (3 วินาที) ยาวกว่า
เวลาที่ใช้ในการทำงานของ goroutine (2 วินาที) ดังนั้น
โปรแกรมจะพิมพ์ "result 2" แทนที่จะเข้าสู่กรณี
timeout
*/
